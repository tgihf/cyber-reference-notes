# Stack Canary Bypasses

> As discussed [[binary-protection-mechanisms#Stack Canary|here]], a stack canary prevents you from overflowing the stack and overwriting the current funciton's return address, inevitably overwriting the instruction pointer to direct the program's control flow.

---

## Stack Canary Bypass Methodology

1. Disclose the binary's stack canary
	- There are two reliable techniques for disclosing a binary's stack canary:
		1. [[stack-canary-bypasses#Leaking the canary|Leaking the canary]]
		2. [[stack-canary-bypasses#Brute-forcing the canary|Brute-forcing the canary]]
2. [[stack-canary-bypasses#Incorporating the canary into your exploit|Incorporate the canary]] into your exploit


---

## Leaking the canary

Depending on the program, it may be possible to coerce it into diclosing its stack canary, which you could subsequently incorporate into your exploit to ensure it passes the program's canary check.

There's a lot of ways you can coerce the program into leaking its canary, all of which center around the program taking in your input, doing something with it, and then sending you the output of that something. Pay special attention to all these components of the program. Inspect them in a decompiler and debugger to ensure you understand how it may be possible to leverage them to leak the canary.

A notable example of being able to leak a stack canary involves the program passing your input into one of C's format functions ([printf](https://man7.org/linux/man-pages/man3/printf.3.html), [sprintf](https://linux.die.net/man/3/sprintf), etc.) and returning the output. In this situation, you can exploit the [format string bug](https://ir0nstone.gitbook.io/notes/types/stack/format-string) which allows you to leak the bytes at an arbitrary offset from the stack pointer. Use a debugger to determine the offset from the stack pointer just before this function call, pass in the required format string, and leak the canary.

### References

CCTC `inventory2`

[ir0nstone - Format String Bug](https://ir0nstone.gitbook.io/notes/types/stack/format-string)

---

## Brute-forcing the canary

If the following conditions hold true, it may be possible to brute-force the program's stack canary:

1. The program has a master/slave architecture, in which a parent process dispatches children processes which handle user input in a way that is vulnerable to a stack-based buffer overflow
	- This is significant because the stack canary is held constant between parent and children processes
2. The program's behavior makes it possible for you to differentiate a nominal input case (canary hasn't been overwritten) and a malicious input case (canary has been overwritten)

Here's an example of how you would brute-force the stack canary of a program that meets these conditions:

Consider a program (compiled with a stack canary) that listens on a socket and for each client that connects to the socket, dispatches a child process to handle the request. These child processes handle input from the client in a way that is vulnerable to a stack-based buffer overflow.

Let's say the program's stack canary is `0x12345678`. The parent process and all its children processes will share this canary.

You connect to the socket and send it a payload that overwrites up to the canary's first byte (i.e., `0x12`). You iterate through all possible 1-byte values (256 total), overwriting this first byte. When you overwrite it with a byte that doesn't match, the program's behavior will let you know. When you overwrite it with the matching byte, the program's behavior will differ, letting you know you have the correct byte value.

Continue this with the other bytes in the canary (`0x34`, `0x56`, and `0x78`) until you have successfully disclosed the entire canary.

### References

[YouTube - Stack Canary - Aaron Yoo](https://www.youtube.com/watch?v=N7kGd76evsM)

---

## Incorporating the canary into your exploit

Once you've either leaked or brute-forced a program's stack canary, you'll incorporate it into your exploit so that even after overflowing the stack and overwriting the instruction pointer, you'll still pass the program's canary check.

To do this, you have to make sure the leaked/brute-forced canary is at the proper offset in your payload such that it perfectly overwrites the legitimate canary on the stack.

Follow this methodology:

1. Open the program in a decompiler (i.e., [[ghidra]])
2. Determine the function inside of which the buffer overflow vulnerability lies
3. Within this function, determine where it assigns the stack canary
	- If stack canary assignment doesn't happen in this function, determine where the canary is assigned in `main`--the canaries will be the same
4. Open the program in a debugger
5. Set a breakpoint where the canary is assigned
6. Set a breakpoint just after the point at which the buffer overflow vulnerability can be exploited
8. Run the program
9. Use the first breakpoint to determine the value of the canary for that execution
10. Continue to the second breakpoint
11. Supply easily identifiable input that *doesn't* overflow the buffer
12. Use the second breakpoint to determine the offset from the beginning of the user input to the canary (whose value was identified in #9)
13. Use this offset to incorporate the dynamically leaked/brute-forced canary in your payload in the exploit

---

## References

[ir0nstone - Stack Canaries](https://ir0nstone.gitbook.io/notes/types/stack/canaries)

# Socket Reuse

> Used in situations where you don't have enough space for any useful shellcode. Leverages an existing socket file descriptor and a call to [recv](https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv) to stage additional shellcode to be executed.

---

## Prerequisites

- [ ] You can overflow the stack and reliably overwrite EIP and some space on the stack after it with input you control
- [ ] You don't have enough space for useful shellcode
- [ ] The program has an open socket
- [ ] The program makes calls to `recv()` at some point during its execution

---

## Methodology

`recv()`'s signature:

```c
int recv(
  [in]  SOCKET s,
  [out] char   *buf,
  [in]  int    len,
  [in]  int    flags
);
```

1. Push `flags` (you'll probably just want it to be zero)
2. Push `len`
	- This is the number of shellcode bytes you'll be staging
3. Push `buf`
	- This is the address where you'll be staging the additional shellcode
	- `recv()` will write data from this address and down the stack (to higher addresses)
	- If possible, try to make this just after the `recv()` call so you can slide right into the shellcode once it returns
4. Push `s`
	- This is the file descriptor of the socket
	- To get this:
		- Open the program in a debugger and find other calls on the socket (`recv()`, `send()`, etc.)
		- Just before each call, note the value passed in as `s` (it will likely be a smallish integer, like 0x128)
		- With that value in mind, step through to where your shellcode is constructing the `recv()` call and see if there are any references to that value in the registers or on the stack
5. Call the address of `recv()`
	- This is generally done by storing the address of the function in EAX and then calling EAX
	- You can get *the address of the address of* `recv()` in [[ghidra#PE32 Find the Address of the address of an External Function|ghidra]]
	- You'll need to dereference this value before you call it, like `mov eax, 0x12345678; call [eax]`
6. If all goes well, at this point, the target is listening on the socket. If you send it additional shellcode, it will write that shell code to `buf`
7. Execute the staged shellcode at `buf`
	- If you managed to put `buf` just after the call to `recv()`, you're good to go! Once `recv()` returns, the shellcode will be executed
	- If you didn't manage to put `buf` just after the call to `recv()`, perhaps you can simply jump to `buf` after `recv()` returns

---

## References

[Using Socket Reuse to Exploit Vulnserver - rastating](https://rastating.github.io/using-socket-reuse-to-exploit-vulnserver/)

[HTB Hancliffe](https://www.youtube.com/watch?v=kA-bkftyyY0)

[Win32 - recv](https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv)
